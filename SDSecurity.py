import os
import json
import stat
import hashlib
import base64

from Crypto.Cipher import AES, PKCS1_OAEP
from Crypto.Random import get_random_bytes
from Crypto.PublicKey import RSA
from Crypto.Signature import pss
from Crypto.Hash import SHA256

ITERATIONS = 100000     # PBKDF2 hash work factor (tweak according to performance/security needs)
SALT_SIZE = 16          # 16-byte salt used for hashing
PEPPER_SIZE = 16        # 16-byte pepper used for hashing
AES_KEY_SIZE = 32       # 32-byte (256-bit) AES key
RSA_KEY_SIZE = 2048     # 2048-bit RSA key 
TAG_SIZE = 16           # AES-GCM generates 16-byte tag
NONCE_SIZE = 16         # AES-GCM generates 16-byte nonce

# ----- Hashing -----
def derive_key_pbkdf2(password, salt, pepper=b"", iterations=ITERATIONS, key_size=AES_KEY_SIZE, algo='sha256'):
    """Derive a key from `password` using PBKDF2."""
    password = password.encode() + pepper
    return hashlib.pbkdf2_hmac(algo, password, salt, iterations, key_size)

def hash_b2b(data, salt=b"", pepper=b"", key=b""):
    """Returns blake2b hash of `data`"""
    data = data.encode() + pepper
    b2b = hashlib.blake2b(key=key, salt=salt)
    b2b.update(data)
    return b2b.digest()

# Byte generation for salt & pepper
# - Iffy on if I want it like this or as more specific individual functions
# - - Don't like salt size being defined in the main program
# - should create multiple salts and choose one at random, so correct salt is not stored by itself
def create_and_store_bytes(n, filepath):
    """Returns `n` pseudo-randomly generated bytes, which are saved to `filepath`"""
    n_bytes = get_random_bytes(n)
    secure_write(n_bytes, filepath)
    return n_bytes

# ----- Encryption -----
def encrypt_aes(data, key):
    """
    Returns AES-GCM encrypted `data` as bytes using `key`.\n
    Format: `nonce` | `ciphertext` | `tag`
    """
    cipher = AES.new(key, AES.MODE_GCM)
    ciphertext, tag = cipher.encrypt_and_digest(data)
    return cipher.nonce + ciphertext + tag

def decrypt_aes(data, key):
    """
    Returns AES-GCM decrypted `data` as bytes using `key`.\n
    Expects `data` in format: `nonce` | `ciphertext` | `tag`
    """
    nonce = data[:NONCE_SIZE]
    tag = data[-TAG_SIZE:]
    ciphertext = data[NONCE_SIZE:-TAG_SIZE]
    cipher = AES.new(key, AES.MODE_GCM, nonce=nonce)
    return cipher.decrypt_and_verify(ciphertext, tag)

def generate_rsa_key_pair():
    """Returns generated RSA key pair as `(private, public)`"""
    key = RSA.generate(RSA_KEY_SIZE)
    private_key = key.export_key()
    public_key = key.public_key().export_key()
    return private_key, public_key

def encrypt_rsa(data, public_key):
    """Returns RSA encrypted `data` as bytes using `public_key`"""
    rsa_key = RSA.import_key(public_key)
    cipher = PKCS1_OAEP.new(rsa_key)
    return base64.b64encode(cipher.encrypt(data))

def decrypt_rsa(data, private_key):
    """Returns RSA decrypted `data` as bytes using `private_key`"""
    rsa_key = RSA.import_key(private_key)
    cipher = PKCS1_OAEP.new(rsa_key)
    return cipher.decrypt(base64.b64decode(data))

# ----- Signed Certificate -----
def sign_message(data, private_key):
    """Returns hash of `data` signed using `private_key`"""
    rsa_key = RSA.import_key(private_key)
    hash_obj = SHA256.new(data.encode())
    signature = pss.new(rsa_key).sign(hash_obj)
    return base64.b64encode(signature).decode()

def verify_signature(data, signature, public_key):
    """
    Verify signature using RSA public key.\n
    Returns `True` given a valid signature, `False` otherwise.
    """
    rsa_key = RSA.import_key(public_key)
    hash_obj = SHA256.new(data.encode())
    sig = base64.b64decode(signature)
    verifier = pss.new(rsa_key)
    try:
        verifier.verify(hash_obj, sig)
        return True
    except:
        return False

def create_certificate(email, full_name, public_key, private_key):
    """
    Creates simple self-signed certificate for authentication.\n
    Format: `email`|`name`|`public_key`
    """
    cert_data = {
        "email": email,
        "name": full_name,
        "public_key": public_key.decode()
    }
    cert_string = f"{email}|{full_name}|{public_key.decode()}"
    signature = sign_message(cert_string, private_key)
    cert_data["signature"] = signature
    return cert_data

def verify_certificate(cert):
    """
    Verifies certificate using public RSA key.\n
    Returns `True` given a valid certificate, `False` otherwise.
    """
    try:
        email = cert.get("email")
        name = cert.get("name")
        pub_key = cert.get("public_key")
        sig = cert.get("signature")
        cert_string = f"{email}|{name}|{pub_key}"
        return verify_signature(cert_string, sig, pub_key)
    except:
        return False

# ----- File I/O -----
def secure_write(data, filepath):
    """Writes `data` to `filepath` with owner-only R/W permissions (mode 600)."""
    with open(filepath, "wb") as file:
        file.write(data)
    os.chmod(filepath, stat.S_IRUSR | stat.S_IWUSR)

# Called secure_read for consistency, no security here
def secure_read(filepath):
    """Returns data stored in `filepath`."""
    with open(filepath, "rb") as file:
        return file.read()

def load_and_decrypt(filepath, key):
    """
    Returns decrypted JSON object stored in `filepath` using `key`.\n
    If `filepath` does not exist, returns `{}`
    """
    if os.path.exists(filepath):
        try:
            data = secure_read(filepath)
            decrypted = decrypt_aes(data, key)
            return json.loads(decrypted)
        except Exception as e:
            return {}
    return {}

# Can't serialize bytes to json, so encrypting entire object for storage
# Downside: Data not encrypted while in memory
def encrypt_and_store(obj, filepath, key):
    """Encrypts JSON-serializable `obj` and writes it to `filepath`."""
    data = json.dumps(obj).encode()
    encrypted = encrypt_aes(data, key)
    secure_write(encrypted, filepath)
