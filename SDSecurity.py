import os
import json
import random
import stat
import hashlib
import hmac

from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes

ITERATIONS = 100000     # PBKDF2 hash work factor (tweak according to performance/security needs)
SALT_SIZE = 16          # 16-byte salt used for hashing
PEPPER_SIZE = 16        # 16-byte pepper used for hashing
# PICKLE_SIZE = 16      # 16-byte pickle used for hashing
KEY_SIZE = 32           # 32-byte (256-bit) AES key 
TAG_SIZE = 16           # AES-GCM generates 16-byte tag
NONCE_SIZE = 16         # AES-GCM generates 16-byte nonce

# ----- Hashing -----
def derive_key_pbkdf2(password, salt, pepper=b"", iterations=ITERATIONS, key_size=KEY_SIZE, algo='sha256'):
    """Derive a key from `password` using PBKDF2."""
    password = password.encode() + pepper
    return hashlib.pbkdf2_hmac(algo, password, salt, iterations, key_size)

def hash_b2b(data, salt=b"", pepper=b"", key=b""):
    """Returns blake2b hash of `data`"""
    data = data.encode() + pepper
    b2b = hashlib.blake2b(digest_size=KEY_SIZE, key=key, salt=salt)
    b2b.update(data)
    return b2b.digest()

# Byte generation for salt & pepper
# - Iffy on if I want it like this or as more specific individual functions
# - - Don't like salt size being defined in the main program
# - should create multiple salts and choose one at random, so correct salt is not stored by itself
def create_and_store_bytes(n, filepath):
    """Returns `n` pseudo-randomly generated bytes, which are saved to `filepath`"""
    n_bytes = get_random_bytes(n)
    secure_write(n_bytes, filepath)
    return n_bytes

# ----- Depricated -----
# Pickles unused for now
# def get_rand_pickle(filepath):
#     pickle_jar = []
#     with open(filepath, "rb") as file:
#         pickle = file.read(PICKLE_SIZE)
#         while pickle:
#           pickle_jar.append(pickle)
#           pickle = file.read(PICKLE_SIZE)
#     return random.choice(pickle_jar)

# ----- Encryption -----
def encrypt_aes(data, key):
    """
    Returns AES-GCM encrypted `data` as bytes.\n
    Format: `nonce` | `ciphertext` | `tag`
    """
    cipher = AES.new(key, AES.MODE_GCM)
    ciphertext, tag = cipher.encrypt_and_digest(data)
    return cipher.nonce + ciphertext + tag

def decrypt_aes(data, key):
    """
    Returns AES-GCM decrypted `data` as bytes.\n
    Expects `data` in format: `nonce` | `ciphertext` | `tag`
    """
    nonce = data[:NONCE_SIZE]
    tag = data[-TAG_SIZE:]
    ciphertext = data[NONCE_SIZE:-TAG_SIZE]
    cipher = AES.new(key, AES.MODE_GCM, nonce=nonce)
    return cipher.decrypt_and_verify(ciphertext, tag)

# ----- File I/O -----
def secure_write(data, filepath):
    """Write data with owner-only R/W permissions (mode 600)."""
    with open(filepath, "wb") as file:
        file.write(data)
    os.chmod(filepath, stat.S_IRUSR | stat.S_IWUSR)

# Called secure_read for consistency, no security here
def secure_read(filepath):
    """Read data from a file."""
    with open(filepath, "rb") as file:
        return file.read()

def load_and_decrypt(filepath, key):
    """Returns decrypted JSON object stored in `filepath`, if it exists."""
    if os.path.exists(filepath):
        try:
            data = secure_read(filepath)
            decrypted = decrypt_aes(data, key)
            return json.loads(decrypted)
        except Exception as e:
            return {}
    return {}

# Can't serialize bytes to json, so encrypting entire object for storage
# Downside: Data not encrypted while in memory
def encrypt_and_store(obj, filepath, key):
    """Encrypts JSON-serializable `obj` and writes it to `filepath`."""
    data = json.dumps(obj).encode()
    encrypted = encrypt_aes(data, key)
    secure_write(encrypted, filepath)
